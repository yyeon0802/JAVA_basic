package day0302;

// 기본형 데이터 타입 01
// 정수형 데이터 타입


// 정수란?
//  - 소수점이 존재하지 않는 온전한 숫자

// 프로그래밍에는 정수형 기본 데이터 타입에 4가지가 존재한다.
//  1. byte
//      - 크기    :   8비트(=1byte 8자리 맨 앞자리 0+ 1-)
//      - 범위    :   (-2^7) ~ (2^7 -1)  -128 ~ 127
//               :   2의 8승 128+128 = 256가지의 숫자 저장
//           1 0 0 0 0 0 0 = -128         
//           1 1 1 1 1 1 1 = -1         
//           컴퓨터의 숫자 체계 처음과 끝이 안 이어진 O 원형
//           127 = 0111 1111 / -128 = 1000 0000
//           130 = 1000 0010 -> 바이트에 넣으면 1000 0010앞자리가 1 그럼 -인데?
//              이러면 바이트는 -126됨 !문제점 발생
//           10진수 127 다음에 왼쪽으로 한칸가면 -128 이 되버림 = 오버플로우
//           10진수 -128 다음에 오른쪽 한칸가면 127 이 되버림 = 언더플로우
//           511 바이트로-> 100000000 크기가 넘어가서 0만 들어가서 0 되버림


//  2. short
//      - 크기    :   16비트(=2byte)
//      - 범위    :   (-2^15) ~ (2^15 -1)
//      - 범위    :   (최소값 -1000 0000 0000 0000 = -32768) ~ (2^15 -1)

//  3. int 
//      - 크기    :   32비트(=4byte)
//      - 범위    :   (-2^31) ~ (2^31 -1)

//  4. long
//      - 크기    :   64비트(=8byte)
//      - 범위    :   (-2^63) ~ (2^63 -1)


//  비트
//      - 비트란 bit 2진법 숫자의 자릿수를 뜻한다.
//          ex) 8비트의 경우 8자리 2진법 숫자를 뜻한다.

//  진법 
//      - 10진법 : 각 자리가 0~9까지 숫자로 이루어져 있고 각 자리는 10의 제곱을 뜻함
//      - 2진법 : 각 자리가 0 , 1 숫자로 이루어져 있고 각 자리는 2의 제곱을 뜻함

// 자바에서는 우리가 코드에 직접 적는 10진법 값을 자동으로 int로 인식하고
// 알아서 형변환을 해주지만 더 작은 데이터 타입의 경우, 범위를 벗어나면 에러가 발생한다.

public class Ex06Integer {
    public static void main(String[] args) {
        // byte변수 myByte를 선언해보자
        byte myByte;
        
        // myByte값에 10이란 값을 넣어보자
        myByte = 10;
        
        // 화면에 myByte에 현재 할당 된 값을 출력해보자
        System.out.println(myByte);
        
        // int 변수 myInt 를 선언해보자
        int myInt;
        
        // myInt에 130 값을 넣어보자
        myInt = 130;
        
        // 화면에 myInt에 현재 할당된 값을 출력해보자
        System.out.println(myInt);
    
        // 암시적 형변환 체험해 보기
        
        // myInt에 myByte의 현재값을 할당해라
        // myInt의 데이터타입은 32비트인 int이고
        // myByte의 데이터타입은 8비트는 byte이기 때문에
        // myInt에 myByte의 값을 할당하면
        // 암시적 형변환이 발생하여 byte값이 int로 변환되어 
        // myInt에 할당된다.
        myInt = myByte; 
        //빨간줄 오류x ex) 1010(8비트) - > 0000 x7번 하고 1010 하면 32비트 형변환
        //빨간줄 오류x ex) 1000 0000 (= -128)(8비트) - > 1111 x6번(short의 최소값에 2의 14승부터 즉 양수를 13승 ... 128까지 를 더하면 
        // 음수 short의 최소값을 양수로 더해감) 하고 1000 0000하면 32비트변환
        //(short 최소값 -1000 0000 0000 0000 = -32768)
        
        //myByte에 myInt의 현재값을 할당해라
        // myByte = myInt; // 앞자리 0000도 컴퓨터는 없는 0이 아니라 데이터로 치기때문에
        
        // 강제로 명시적 형변환  myInt를 8자리로 잘라라
        // 이때에는 myByte의 데이터타입이 myInt의 데이터타입보다 작으므로
        // 암시적 형변환이 일어날 수 없다.
        // 따라서 우리가 명시적으로 "이 데이터타입으로 바꾸라"고 컴퓨터에게 지시를 내려한다.
        // 즉 명시적 형변환을 해야한다.
        myByte = (byte)myInt;
        
        
        // 오버플로우 경험해보기
        
        // myByte에 140을 할당해보자
        
        // 이때에는 java가 140이란 숫자를 미리 체크해서
        // byte가 표현 할 수 없는 범위인 것을 확인하고 에러를 띄우므로
        // 우리가 명시적 형변환을 통해 140값을 byte로 바꾸어야 한다.
        myByte = (byte)140; //140 = 128 + 12
        
        System.out.println(myByte);
        
        // 언더플로우 경험해보기
        
        // myByte에 -150을 할당해 보자 
        // -150 = -129 + -21
        // byte 기분 -129는 127로 언더플로우가 되므로
        // -150 = 127 + -21 이 된다
        // 따라서 결과가 106이 된다.
        
        myByte = (byte) -150;
        System.out.println(myByte);
        
        // java에서는 정수형 값을 기보적으로 int로 받아들인다.
        // 즉 우리도 정수형 데이터타입이 필요할 경우 기본적으로 int를 쓰고
        // -20억 ~ 20억을 벗어날 경우에만 long을 쓰면 된다.
        
        
        
    }
}
